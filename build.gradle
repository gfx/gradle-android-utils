buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.sun.codemodel:codemodel:2.6'
    }
}

import java.awt.image.BufferedImage
import java.awt.Color
import javax.imageio.ImageIO
import com.sun.codemodel.JCodeModel
import com.sun.codemodel.JMod

private int toGray(color) {
    def a = (color & 0xFF000000)
    def r = (color & 0x00FF0000) >> 16
    def g = (color & 0x0000FF00) >>  8
    def b = (color & 0x000000FF)

    def c = (int)((2.0*r + 4.0*g + b) / 7.0) //
    return a | (c << 16) | (c << 8) | c
}

ext.iconToGrayScale = { File inputFile, File outputFile ->
    def img = ImageIO.read(inputFile)
    for (int y = 0; y < img.getHeight(); y++) {
        for (int x = 0; x < img.getWidth(); x++) {
            def color = img.getRGB(x, y)
            img.setRGB(x, y, toGray(color))
        }
    }

    outputFile.getParentFile().mkdirs()
    ImageIO.write(img, "png", outputFile)
}

/**
 * Makes gray-scaled launcher icons for the "debug" build variant.
 */
ext.makeGrayscaleLauncherIcon = { File dir, String name ->
    fileTree(dir: dir, include: "res/drawable*/$name").each { File ic ->
        def outputFile = file(ic.getPath().replaceAll("/main/", "/debug/"))
        iconToGrayScale(ic, outputFile)
    }
}

ext.writeProperties = { File propertiesFile, Map<String, String> dict ->
    def s = ""
    dict.each { key, value ->
        s += "$key=$value\n"
    }
    logger.info("writing $propertiesFile")
    propertiesFile.write(s)
}

/**
 * Initialize local.properties which includes sdk.dir, ndk.dir and extra properties.
 */
ext.initSdkDir = { Map<String, String> extra = null ->
    def localPropFile = file("local.properties")

    if (!localPropFile.exists()) {
        def dict = new HashMap<String, String>()
        if (extra != null) {
            dict.putAll(extra)
        }

        // sdk.dir is required
        [
            System.getenv("ANDROID_HOME"),
            System.getenv("ANDROID_SDK"),
            "/usr/local/opt/android-sdk",
            "/Applications/Android Studio/sdk"
        ].each { dir ->
            if (dir != null && file(dir).exists()) {
                dict["sdk.dir"] = dir
                return;
            }
        }
        if (dict["sdk.dir"] == null) {
            throw new RuntimeException("No Android SDK found.")
        }

        // ndk.dir is optional
        [
            System.getenv("ANDROID_NDK"),
            "/usr/local/opt/android-ndk",
        ].each { dir ->
            if (dir != null && file(dir).exists()) {
                dict["ndk.dir"] = dir
                return;
            }
        }

        writeProperties(localPropFile, dict)
    }
}

/**
 * Writes Android resources.
 * e.g. writeResources(file("src/main/res/values/_generated.xml"), ["foo" : "bar"])
 */
ext.writeResources = { File file, Map<String, String> dict ->
    def s = ""
    s += """<?xml version="1.0" encoding="utf-8"?>\n<resources>\n"""
    dict.each { key, value ->
        s += """<string name="$key">$value</string>\n"""
    }
    s += """</resources>\n"""

    logger.info("writing $file")
    file.write(s)
}

/**
 * Representation of Semantic Version (major.minor.patchlevel)
 */
public class Version {
    public final int major;
    public final int minor;
    public final int patchLevel;

    public final String source;

    public Version(String v) {
        source = v.trim()

        def parts = source.split("\\.", 3)
        major = Integer.valueOf(parts[0])
        minor = Integer.valueOf(parts[1])
        patchLevel = Integer.valueOf(parts[2])
    }

    @Override
    public String toString() {
        return String.format("%s (%s)", toVersionName(), toVersionCode())
    }

    public String toVersionName() {
        return source
    }

    public int toVersionCode() {
        return major * (1000 * 1000) + minor * 1000 + patchLevel;
    }
}

ext.parseVersion = { String versionString ->
    return new Version(versionString)
}

ext.readVersion = { File file ->
    def s = new String(file.readBytes())
    return parseVersion(s)
}

String camerize(String snakeCased) {
    def first = snakeCased.substring(0, 1)
    def rest  = snakeCased.substring(1)
    return first.toUpperCase() + rest.toLowerCase()
}

ext.generateViewHolders = { xmlFiles ->
    // TODO: get project package name
    def pkg = "com.example"
    xmlFiles.each { File layoutXml ->
        def simpleName = layoutXml.getName().split('\\.')[0]
        def className = simpleName.split('_').collect { String part ->
            camerize(part)
        }.join('')
        println("Generating ${className}.java from $layoutXml")

        def model = new JCodeModel()
        def vhClass = model._class(pkg + ".viewholder.$className")

        def androidNs = new groovy.xml.Namespace("http://schemas.android.com/apk/res/android", "android")
        def xmlParser = new XmlParser()
        def layout = xmlParser.parse(layoutXml)
        def walk;
        walk = { element ->
            def widgetId = element.attribute(androidNs.get("id"))
            if (widgetId != null) {
                def parts = widgetId.split('/')
                if (parts[0] == "@+id") {
                    vhClass.field(JMod.PUBLIC, model.ref("android.widget.${element.name()}"), parts[1])
                }
            }

            element.children().each { walk(it) }
        }

        walk(layout)

        def javaSourceDir = file(".gen/java")
        javaSourceDir.mkdirs()
        model.build(javaSourceDir)
    }
}
